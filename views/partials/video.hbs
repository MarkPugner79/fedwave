    <meta charset="utf-8">
    <title>FedWave</title>
    <!-- link to jquery 2.0 <script src="js/jquery-2.0.0.js"></script> -->
    <script src="/socket.io/socket.io.js"></script>
    
    <script
			  src="https://code.jquery.com/jquery-2.2.4.min.js"
			  integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44="
			  crossorigin="anonymous"></script>
    <!-- link to bootstrap 2.3.1 <script src="js/bootstrap.js"></script>  -->
    <script src="https://cdn.usebootstrap.com/bootstrap/2.3.2/js/bootstrap.min.js"></script>
    <!--<link href="css/bootstrap.css" rel="stylesheet">-->
    <!-- <link href="https://cdn.usebootstrap.com/bootstrap/2.3.2/css/bootstrap.min.css" rel="stylesheet"> -->
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/rickshaw/1.6.3/rickshaw.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/rickshaw/1.6.3/rickshaw.min.css">

    <script src="/p2p-media-loader-core.js"></script>
    <script src="/p2p-media-loader-hlsjs.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/clappr@latest"></script>
     <script src="/p2p-graph.js"></script>
    <link href="/bs.css" rel="stylesheet">
    <style>
      
        .labelhelper{
            
            color: #789922;
        }
    
       .avatar{
            float: left;
            width: 34px;
            height: 34px;
            
        }
    
        video {
            width: 95%;
        }
        button, input, select {
            font-family: Myriad, Arial, Verdana;
            font-weight: normal;
            border-top-left-radius: 3px;
            border-top-right-radius: 3px;
            border-bottom-right-radius: 3px;
            border-bottom-left-radius: 3px;
            padding: 4px 12px;
            text-decoration: none;
            color: rgb(27, 26, 26);
            display: inline-block;
            box-shadow: rgb(255, 255, 255) 1px 1px 0px 0px inset;
            text-shadow: none;
            background: -webkit-gradient(linear, 0% 0%, 0% 100%, color-stop(0.05, rgb(241, 241, 241)), to(rgb(230, 230, 230)));
            font-size: 20px;
            border: 1px solid red;
            outline:none;
        }
        button:active, input:active, select:active, button:focus, input:focus, select:focus {
            background: -webkit-gradient(linear, 0% 0%, 0% 100%, color-stop(5%, rgb(221, 221, 221)), to(rgb(250, 250, 250)));
            border: 1px solid rgb(142, 142, 142);
        }
        button[disabled], iput[disabled], select[disabled] {
            background: rgb(249, 249, 249);
            border: 1px solid rgb(218, 207, 207);
            color: rgb(197, 189, 189);
        }
        input, input:focus, input:active {
            background: white;    
        }

        #video-preview{
            display: none;
        }
    
    body{background-color:#2f2f2f}
    </style>
    <div id="topinfovideo" >
        <div class="labelhelper">
            Watch live streams happening right NOW!
            <p class="no-mobile">
            Use peer-to-peer protocol to broadcast your video over 20+ users.
            Maybe have a stream slug handler to watch a specific user
            </p>
            <div><li>Are you using a vpn?</li><li>Are you sure you are using a vpn?</li><li>Are you really sure you are using a vpn?</li></div>
            <div id="ipinfo" onclick="getMyIp()">Click to check IP info...</div>
    </div>
  </div>
    <section class="make-center">
      <p  style="margin: 0; padding: 0; padding-bottom: 20px;">
          <div class="make-center">
              <!-- This should be replaced by a user list of live streams -->
                    <input class="hide" type="text" id="broadcast-id" value="room-xyz" autocorrect=off autocapitalize=off size=20>
                    <button class="hide" id="open-or-join">Open or Join Broadcast</button>
                
            <div id="livestreams">

            </div>
          <div class="make-center" id="broadcast-viewers-counter"></div>
      </p>
      <!-- Need to fix the CSS that the player uses or figure out how to bind it via the video JS instead so there is a div inside the player that gets a custom style set to it... it wraps the inner player -->
        <div id="video-container">
        <div id="player"></div>
        <video id="video-preview" controls ></video>
       
        <div id="video-controls">
            <button type="button" id="play-pause">Play</button>
            <!---<input type="range" id="seek-bar" value="0">-->
            <button type="button" id="mute">Mute</button>
            <input type="range" id="volume-bar" min="0" max="1" step="0.1" value="1">
            <button type="button" id="full-screen">Full-Screen</button>
            <!---
            <button type="button" id="vidmute">Video Mute</button>
            <button type="button" id="audmute" onclick="hookAudio">Audio Mute</button>-->
        </div>
    </div>
    <!---
     <audio id="preview-audio" controls></audio>
     -->
        <div class="hide" class="graph-container" id="bitrateGraph">
            <div>Bitrate</div>
            <canvas id="bitrateCanvas"></canvas>
            <input class="hide" type="text" id="broadcast-id-slug" value="room-xyz#1234" autocorrect=off autocapitalize=off size=20>
            <button class="hide" id="join">Join Broadcast</button>
        </div>
        <!--<div id="chart_container">
                    <div id="legend"></div>
                    <div id="legend-totals"></div>
                    <div id="y_axis"></div>
                    <div id="chart"></div>
                </div>-->
                
                <h3>Trackers:</h3>
                <div id="announce"></div>
                <!--<div id="graph"></div>-->
        
  </section>
    <style>
        
    </style>

    <script>

        // so the graph is the peer graph, not the usage chart
            // so from debugging it works with clappr, would be nice to get it to work with the other videojs player
            let downloadStats = [];
            let downloadTotals = { http: 0, p2p: 0 };
            let uploadStats = [];
            let uploadTotal = 0;
            let loadSpeedTimespan = 10; // seconds
            
            let grapher = require('p2p-graph');
            
            let graph = new grapher("#graph");
            
            let active_channel = "none";
            let blur_active = false;
            let blur_active_last = false;
            
            let channel_blur_stat = false;
            //let player = [];
            
            let channel_started_on = "not set";

              function nsfwBlur(){
                // toggles the nsfw blur for the video via a hot key hook in the browser or buton
                //$('#my-player_html5_api').css("filter: blur(1.5rem);");
                //$('#my-player_html5_api').addClass("blur");
                $('#my-player_html5_api').toggleClass("blur");
                blur_active_last = blur_active;
                blur_active = !blur_active;
            }
            
            function get(name){
                    if(name=(new RegExp('[?&]'+encodeURIComponent(name)+'=([^&]*)')).exec(location.search))
                        return decodeURIComponent(name[1]);
                }
                
            function getStartInfo(){
                    const chanval = get('channel');
                    // use this to set and force the channel to be the selection
                    if(chanval){
                        console.log("Found channel to watch:", chanval);
                    }
            
            }
            
            getStartInfo();

            function showdescriptioninfo(){
                // get the description text
                const apichannels="/v1/api/channels/live"
                $.get(apichannels, function(data, status){
                    const channelinfo_str = JSON.stringify(data, null, 4)
                    const channel_info_obj =  JSON.parse(channelinfo_str)
                    for( channel in channel_info_obj.users){
                        if(channel_info_obj.users[channel].name == channel_started_on){
                            alert(channel_info_obj.users[channel].title)
                        }
                    }
                })
            }
        
            function getChannelInfo(){
                    console.log("updating the channel list...")
                    // update the channel list
                    
                    
                    //const apichannels="https://api.bitwave.tv/api/channels/live"
                    const apichannels="/v1/channels/live";
                    $.get(apichannels, function(data, status){
                        //alert("Data: " + data + "\nStatus: " + status);
                        console.log(data);
                        console.log(JSON.stringify(data, null, 4))
                        const channelinfo_str = JSON.stringify(data, null, 4)
                        const channel_info_obj =  JSON.parse(channelinfo_str)
                        console.log("after data printed");
                        //const channels = data;//JSON.parse(data);
                        // get selection
                        const selected_channel = $( "#channelselect option:selected" ).text();
                        $('#channelselect').empty();// clear the list and add the new options back in
                        $('#channelselectoffline').empty();
                        
                        //for( channel in channel_info_obj.users){
                        for( channel in channel_info_obj.live){
                            //console.log(channel[channel].name);
                            //console.log(channel[channel].title);
                            //console.log(channel[channel].url);
                            const chname = channel_info_obj.live[channel].name;
                            const churl = channel_info_obj.live[channel].url;
                            const chlive = channel_info_obj.live[channel].live;
                            const nsfw_blur_status = channel_info_obj.live[channel].nsfw;
                            // need to get the stream info and put it in the selelction info
                            //console.log(chname);
                            //console.log(churl);
                            
                            if(chlive ){
                                $('#channelselect').append('<option value="' + churl + '">' + chname + '</option>');
                                
                                // should check if this is our channel that we are watching and set nsfw blur active
                                if( active_channel == chname ){
                                    // get nsfw setting
                                    if(nsfw_blur_status){
                                        if( channel_blur_stat != nsfw_blur_status){
                                            
                                        }
                                        // the idea is to flip to blur if we are changed to nsfw, but if we un blur that it doesn't auto flip back
                                        // we are trying to catch when people go from regular -> nsfw, should make descisions based 
                                        if ( blur_active != nsfw_blur_status){
                                            //nsfwBlur();
                                        }
                                    }
                                }
                            }else{
                            
                                $('#channelselectoffline').append('<option value="' + chname + '">' + chname + '</option>');
                            }
                        }
                        // restore the selection
                        $( "#channelselect option[value="+selected_channel+"]" ).attr('selected','selected') //.text(selected_channel);
                    });
                    
                    // should do a bunch of firebase shit instead
                }
        
        //getChannelInfo();

        function updateChannelPlaying(){
            // now this should change the channel that you are on for messaging
            console.log('get and update the playing item in the player and restart it when it is changed');
            const selected_channel = $( "#channelselect option:selected" ).val();
            console.log('new channel to play playing:',selected_channel);
            // looks like this line needs to be updated to work, so it can find the main video element and select it's source 'my-player' + video_s needs to be part of the selector
            //$("source").attr('src', selected_channel);

        // this was the source setup for the video js setup
    //        $("source:last").attr('src', selected_channel);

            const protocol = "https://cdn.stream.";
            const server_name = $( "#server option:selected" ).text();
            const before_user = ".tv/hls/";
            const after_user = "/index.m3u8";
            const server_stream_url = protocol + server_name + before_user + selected_channel + after_user;
            //$("source").attr('src', server_stream_url);
            if( $( "#channelselect option:selected" ).text().length > 0){
                active_channel = $( "#channelselect option:selected" ).text();
            
                channel_started_on = $( "#channelselect option:selected" ).text();
            }
            var options = {liveui: true,playbackRates: [ 0.25, 0.5, 1, 1.25, 1.5, 1.75, 2 ],};

            // this is the clappr version of the player hookup https://github.com/Novage/p2p-media-loader/blob/master/p2p-media-loader-demo/index.html#L813
            if (p2pml.hlsjs.Engine.isSupported()) {
                    //var engine = new p2pml.hlsjs.Engine();

                    var player = new Clappr.Player({
                        parentId: "#player",
                        source: selected_channel,
                        mute: true,
                        autoPlay: true,
                        
                        playback: {
                            hlsjsConfig: {
                                liveSyncDurationCount: 7,
                                loader: engine.createLoaderClass()
                            }
                        }
                    });

                    p2pml.hlsjs.initClapprPlayer(player);
                } else {
                    document.write("Not supported :(");
                }
            


                //data-setup='{&quot;aspectRatio&quot;:&quot;16:9&quot;}'
                // https://www.watch2gether.com/
            }

        // so this is going to turn into something terrible HERE IS ALL OF THE STUFF FOR P2P START

        if (p2pml.hlsjs.Engine.isSupported()) {
        
                
        
            var engine = new p2pml.hlsjs.Engine();
            
            function restartDemo(){
                downloadStats = [];
                downloadTotals = { http: 0, p2p: 0 };
                uploadStats = [];
                uploadTotal = 0;

                loadSpeedTimespan = 10; // seconds

                const config = {
                    segments: {
                        swarmId: this.swarmId
                    },
                    loader: {
                        rtcConfig: {
                            iceServers: [
                                {
                                    urls: ["stun:stun.l.google.com:19302", "stun:global.stun.twilio.com:3478"]
                                }
                            ],
                            sdpSemantics: "unified-plan"
                        }
                    }
                };
            
                if (trackers) {
                    config.loader.trackerAnnounce = trackers;
                }
            
            }
    
        function initChart() {
            var chartConf = {
                element: document.querySelector("#chart"),
                renderer: 'multi',
                interpolation: "basis",
                stack: false,
                min: 'auto',
                strokeWidth: 1,
                series: [
                    {name: "Upload P2P", color: "#88eab9", data: [], renderer: 'area'},
                    {name: " - P2P", color: "#88b9ea", data: [], renderer: 'area'},
                    {name: " - HTTP", color: "#eae288", data: [], renderer: 'area'},
                    {name: "Download", color: "#f64", data: [], renderer: 'line'}
                ]
            };

            chart = new Rickshaw.Graph(chartConf);

            new Rickshaw.Graph.Axis.X({
                graph: chart,
                tickFormat: () => ''
            });

            new Rickshaw.Graph.Axis.Y({
                graph: chart,
                orientation: 'left',
                element: document.getElementById('y_axis')
            });

            legend = new Rickshaw.Graph.Legend({
                graph: chart,
                element: document.getElementById('legend')
            });

            legendTotals = new Rickshaw.Graph.Legend({
                graph: chart,
                element: document.getElementById("legend-totals")
            });

            chart.render();
            setInterval(updateChartData.bind(this), 500);

            var chartResize = () => {
                chartConf.width = chart.element.clientWidth;
                chart.configure(chartConf);
                chart.render();
            };

            chartResize();
            window.addEventListener("resize", chartResize);
        }

        function refreshChart() {
            if (!chart) {
                return;
            }

            var data0 = chart.series[0].data;
            var data1 = chart.series[1].data;
            var data2 = chart.series[2].data;
            var data3 = chart.series[3].data;
            var lastX = data0.length > 0 ? data0[data0.length - 1].x : -1;

            var seriesDataMapper = (currentValue, index) => ({x: index + lastX + 1, y: 0});

            data0.length = 0;
            data1.length = 0;
            data2.length = 0;
            data3.length = 0;

            var stubData = Array.apply(null, Array(200)).map(seriesDataMapper);
            data0.push.apply(data0, stubData.slice(0));
            data1.push.apply(data1, stubData.slice(0));
            data2.push.apply(data2, stubData.slice(0));
            data3.push.apply(data3, stubData.slice(0));

            chart.update();
        }
        
        function updateLegendTotals() {
            if (!legendTotals) {
                return;
            }

            var httpMb = downloadTotals.http / 1048576;
            var p2pMb = downloadTotals.p2p / 1048576;
            var totalMb = httpMb + p2pMb;
            var uploadMb = uploadTotal / 1048576;

            if (totalMb != 0) {
                legendTotals.lines[0].element.childNodes[1].textContent
                    = "Download - "
                    + Number(totalMb).toFixed(1) + " MiB";

                legendTotals.lines[1].element.childNodes[1].textContent
                    = " - HTTP - "
                    + Number(httpMb).toFixed(1) + " MiB - "
                    + Number((httpMb * 100) / totalMb).toFixed(0) + "%";

                legendTotals.lines[2].element.childNodes[1].textContent
                    = " - P2P - "
                    + Number(p2pMb).toFixed(1) + " MiB - "
                    + Number((p2pMb * 100) / totalMb).toFixed(0) + "%";

                legendTotals.lines[3].element.childNodes[1].textContent
                    = "Upload P2P - "
                    + Number(uploadMb).toFixed(1) + " MiB";
            }
        }
        
        function formatChartLegendLine(index, speed) {
            if (legend) {
                var line = legend.lines[index];
                line.element.childNodes[1].textContent = line.series.name + ' - ' + speed + ' Mbit/s';
            }
        }

        function updateChartData() {
            var downloadSpeed = getDownloadSpeed();
            var http = Number((downloadSpeed.http * 8 / 1000000).toFixed(2));
            var p2p = Number((downloadSpeed.p2p * 8 / 1000000).toFixed(2));
            var total = Number((http + p2p).toFixed(2));
            var upload = Number(getUploadSpeed() * 8 / 1000000).toFixed(2);

            var data0 = chart.series[0].data;
            var data1 = chart.series[1].data;
            var data2 = chart.series[2].data;
            var data3 = chart.series[3].data;
            var x = data0.length > 0 ? data0[data0.length - 1].x + 1 : 0;

            data0.shift();
            data1.shift();
            data2.shift();
            data3.shift();
            data0.push({x: x, y: -upload});
            data1.push({x: x, y: total});
            data2.push({x: x, y: http});
            data3.push({x: x, y: total});
            chart.update();

            formatChartLegendLine(0, total);
            formatChartLegendLine(1, http);
            formatChartLegendLine(2, p2p);
            formatChartLegendLine(3, upload);

            updateLegendTotals();
        }
        
        function getDownloadSpeed() {
            var startingPoint = performance.now() - (loadSpeedTimespan * 1000);
            var httpSize = 0;
            var p2pSize = 0;

            var i = downloadStats.length;
            while (i--) {
                var stat = downloadStats[i];
                if (stat.timestamp < startingPoint) {
                    break;
                }

                if (stat.method === "p2p") {
                    p2pSize += stat.size;
                } else if (stat.method === "http") {
                    httpSize += stat.size;
                }
            }

            downloadStats.splice(0, i + 1);

            return {p2p: p2pSize / loadSpeedTimespan, http: httpSize / loadSpeedTimespan};
        }

        function getUploadSpeed() {
            var startingPoint = performance.now() - (loadSpeedTimespan * 1000);
            var size = 0;

            var i = uploadStats.length;
            while (i--) {
                var stat = uploadStats[i];
                if (stat.timestamp < startingPoint) {
                    break;
                }

                size += stat.size;
            }

            uploadStats.splice(0, i + 1);

            return size / loadSpeedTimespan;
        }
        
    function refreshGraph(p2pLoader) {
            if (!graph) {
                return;
            }

            var nodes = graph.list();
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].id !== "me") {
                    graph.disconnect("me", nodes[i].id);
                    graph.remove(nodes[i].id);
                }
            }

            if (p2pml.hlsjs.Engine.isSupported()) {
                //engine.on(p2pml.core.Events.PeerConnect, onPeerConnect.bind(this));
                //engine.on(p2pml.core.Events.PeerClose, onPeerClose.bind(this));
            }
        }
        
        function onPeerConnect(peer) {
            if (!graph.hasPeer(peer.id)) {
                graph.add({id: peer.id, name: peer.remoteAddress || 'Unknown'});
                graph.connect("me", peer.id);
            }
        }

        function onPeerClose(id) {
            if (graph.hasPeer(id)) {
                graph.disconnect("me", id);
                graph.remove(id);
            }
        }
    
    // on bytes downloaded
    function onBytesDownloaded(method, size){
        //console.log("Fired download:",method, size);
        downloadStats.push({method: method, size: size, timestamp: performance.now()});
            downloadTotals[method] += size;
    }
    
    // on bytes uploaded
    function onBytesUploaded(method, size){
        //console.log("Fired upload:",method, size);
        uploadStats.push({size: size, timestamp: performance.now()});
            uploadTotal += size;
    }
    

    // so we are going to clean up the graphing as nice as it is and probably change it to just write p2p traffic info to a id which can be toggled   
    /*
    initChart();
    refreshGraph();
    */
    
    
    
        
            
            engine.on(p2pml.core.Events.PieceBytesDownloaded, onBytesDownloaded.bind(this));
            engine.on(p2pml.core.Events.PieceBytesUploaded, onBytesUploaded.bind(this));

            var trackerAnnounce = engine.getSettings().loader.trackerAnnounce;
            if (Array.isArray(trackerAnnounce)) {
                document.getElementById("announce").innerHTML = trackerAnnounce.join("<br />");
            }

            /*
            var player = new Clappr.Player({
                parentId: "#player",
                source: "https://fw.rnih.org:7003/live/OELOxBlfXewzq7AV.m3u8",
                mute: true,
                autoPlay: true,
                playback: {
                    hlsjsConfig: {
                        liveSyncDurationCount: 7,
                        loader: engine.createLoaderClass()
                    }
                }
            });

            p2pml.hlsjs.initClapprPlayer(player);*/
        } else {
            document.write("Not supported :(");
        }

        // THIS IS THE END OF THE P2P END

        // https://www.reddit.com/r/WebRTC/comments/hlr5fc/is_it_possible_to_control_volume_per_audio_track/
        // Need a global gain control that all tracks get connected to, or at least the remote stream (being sent) gets connected to and set to -100 or -1 gain to mute it
        //const gainNode = audioContext.createGain();
        // GainNode
        // look at connection.applyConstraints(newconstraings,stream)
        // https://webrtc.org/getting-started/media-capture-and-constraints
        // https://webrtc.org/getting-started/remote-streams

        //=fmtp:109 maxplaybackrate=48000;stereo=1;useinbandfec=1
        // https://blog.teamtreehouse.com/building-custom-controls-for-html5-videos

        // https://www.inwebson.com/html5/custom-html5-video-controls-with-jquery/

        //const audioContext = new AudioContext();
        //const gainNode = audioContext.createGain();
        //let audioNode = null; //audioContext.createMediaStreamSource();

        // the problem seems to be with the tracks and streams and how they get hooked

        // make a URL slug to start watching the stream or request the stream

        // https://web.dev/webaudio-intro/
        // https://gabrieltanner.org/blog/turn-server/

        // add a high bitrate option

        // so the audio works as expected now, we have an option to select the audio high bitrate

        // now to fix the chrome crashing bug,anything that is a direct chrome core will cause it to crash when another one connects [FIXED]
        // to someone that is using chrome, so chromium, brave, chrome all cause crashing, might be based on the user agent [FIXED]
        // Error code: SIGILL is the error I get in both versions [FIXED]

        // need to also debug how to reconnect and setup a room as the streamer if the server restarts

        // https://dev.to/whitphx/python-webrtc-basics-with-aiortc-48id

        // https://github.com/muaz-khan/RTCMultiConnection/wiki#stereo-audio

        function hookAudio(){
            //"preview-audio"
            let audioElem = document.getElementById("preview-audio");
            audioElem.srcObject = connection.attachStreams[0].getTracks()[0];
            window.audioContext = new AudioContext();
            window.gainNode = window.audioContext.createGain();
            //window.gainNode.connect(this.incomingMedia);
            window.audioNode = window.audioContext.createMediaStreamSource(remoteStream);
            window.audioNode.connect(window.gainNode);
            window.audioContext.resume();
            // connection.peers['Playlistbot9k'].streams[0].getTracks()
            // connection.peers['Playlistbot9k'].streams[0].getAudioTracks()[0].enabled = true;
        }


        function muteAudio(){
            connection.attachStreams[0].getTracks()[0].enabled = true;
            connection.attachStreams[0].getTracks()[0].muted = true;
        }
        

        function muteVideo(){
            connection.streamEvents.selectFirst('local').mute('video');
            connection.streamEvents.selectFirst('local').getTracks()[0].enabled = true; // i.e. manually enable audio track after

                connection.streamEvents.selectFirst('local').getTracks()[1].enabled = false; // it will disable only video track
            connection.send({
                myVideoTrackIsMuted: true,
                trackId: connection.streamEvents.selectFirst('local').getTracks()[1].id,
                streamId: connection.streamEvents.selectFirst('local').id
            });

            connection.onmessage = function(event) {
                if(event.data.myVideoTrackIsMuted === true) {
                    document.getElementById(event.data.streamId).pause(); // you can set "srcObject=null" or removeAttribute('srcObject')
                    document.getElementById(event.data.streamId).poster = '/images/poster.png'; // or background image
                }
            };
        }
        

            // Video
            var video = document.getElementById("video-preview");

            // Buttons
            var playButton = document.getElementById("play-pause");
            var muteButton = document.getElementById("mute");
            var fullScreenButton = document.getElementById("full-screen");

            // Sliders
            //var seekBar = document.getElementById("seek-bar");
            var volumeBar = document.getElementById("volume-bar");

            


            // Event listener for the play/pause button
            playButton.addEventListener("click", function() {
            if (video.paused == true) {
                // Play the video
                video.play();

                // Update the button text to 'Pause'
                playButton.innerHTML = "Pause";
            } else {
                // Pause the video
                video.pause();

                // Update the button text to 'Play'
                playButton.innerHTML = "Play";
            }
            });

            // Event listener for the mute button
            muteButton.addEventListener("click", function() {
            if (video.muted == false) {
                // Mute the video
                video.muted = true;

                // Update the button text
                muteButton.innerHTML = "Unmute";
            } else {
                // Unmute the video
                video.muted = false;

                // Update the button text
                muteButton.innerHTML = "Mute";
            }
            });


            // Event listener for the full-screen button
            fullScreenButton.addEventListener("click", function() {
            if (video.requestFullscreen) {
                video.requestFullscreen();
            } else if (video.mozRequestFullScreen) {
                video.mozRequestFullScreen(); // Firefox
            } else if (video.webkitRequestFullscreen) {
                video.webkitRequestFullscreen(); // Chrome and Safari
            }
            });

            // Event listener for the volume bar
            volumeBar.addEventListener("change", function() {
                // Update the video volume
                video.volume = volumeBar.value;
                console.log("New volume set for the video: ",volumeBar.value);
                // now what would be nice is to have an audio track mute or something to hook the audio track up to the control
            });

            // going to leave out the seek bar since you can't seek a webrtc track stream without a local cache
    </script>

    <!--<script src="/RTCMultiConnection.js"></script>-->
    <script src="/RTCMultiConnection_2020_08_26.js"></script>
    <script>

        //connection.peers[remoteUserId].peer.lastAudioTrack = rtpSender.track;
                        //rtpSender.replaceTrack(track);
        // Cool so everyone thinks that muaz is dead
        // so would be a potential replacement https://github.com/feross/simple-peer
        // hls rtmp cnd wrtc https://github.com/cdnbye/hlsjs-p2p-engine
        // https://web.dev/webrtc-basics/
        // connection.peers['peerid'].peer.getLocalStreams()[0] type: 'remote' is the one that goes to the next client in the chain
        // streamid: "{43744dfa-8600-487a-b8b9-814dcc4c3856}"
        // streamsToShare
        // allRemoteStreams

        // https://stackoverflow.com/questions/27908408/webrtc-how-to-mute-local-audio-output#44141610

        // https://webrtc.github.io/samples/
        // audio level https://github.com/webrtc/samples/tree/gh-pages/src/content/getusermedia/volume

        // https://muazkhan.com:9001/demos/Scalable-Broadcast.html
        // https://github.com/muaz-khan/WebRTC-Scalable-Broadcast
        // https://github.com/muaz-khan/WebRTC-Scalable-Broadcast/blob/master/WebRTC-Scalable-Broadcast.js
        // https://github.com/muaz-khan/WebRTC-Scalable-Broadcast/blob/master/RTCMultiConnection.js
        // https://programmer.help/blogs/automatic-audio-gain-and-mute-detection-algorithms-with-complete-c-code.html

        // connection.peers["peerid"].peer.getSenders()[0].track.enabled = true; // now the problem with doing a mute on the track is that it kill the down stream audio
        // https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings volume, might need to be set to 0 for the remote track that is being sent out?
        // https://github.com/muaz-khan/WebRTC-Experiment/issues/663
        // have a local clipping buffer that gives you a minute or 30 seconds that the user can adjust, so they can save and clip the local files
        // Then the fun would be ipfs js client in browser to help share the clip or use webtorrent + magnet link for file/clip sharing
        // add api for user clip sharing list, so you can query all users and see what the clips are named in a p2p way
        // https://github.com/muaz-khan/RTCMultiConnection/issues/1030
        // add audio only option for clients so they end up in the audio only chain
        // https://github.com/eelcocramer/webrtc-mp3-stream/blob/master/client/index.html

        // https://developer.mozilla.org/en-US/docs/Web/API/GainNode is probably needed to be applied to the relay stream
        // https://stackoverflow.com/questions/62744471/webrtc-is-it-possible-to-control-volume-per-audio-track-when-we-have-audio-stre#62745356

        // server side: https://github.com/muaz-khan/WebRTC-Scalable-Broadcast/blob/master/WebRTC-Scalable-Broadcast.js
    // recording is disabled because it is resulting for browser-crash
    // if you enable below line, please also uncomment above "RecordRTC.js"
    // https://github.com/muaz-khan/RTCMultiConnection/tree/master/demos/SSEConnection
    // https://www.rtcmulticonnection.org/docs/getting-started/
    // has a nice chat demo connection.send('hello everyone');
    // and then 
    /*
        // if you want text chat
        connection.session = {
            data: true
        };
        connection.onmessage = function(event) {
            alert(event.userid + ' said: ' + event.data);
        };
        connection.openOrJoin('your-room-id');
    */
    // chat height should match the video height and be hidden until shown by the video
    // the question is... is it p2p or socketio that it goes over

    // https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/autoGainControl
    // applyConstraints seems to be what I'm looking for, then when the other use connects, the stream id for the audio track needs to have the gain control set and added
    // so it can be set to zero?
    // mediaConstraints.audio
    // https://developer.mozilla.org/en-US/docs/Web/API/Media_Capture_and_Streams_API/Constraints#example__constraint_exerciser
    // function applyConstraints exposes track and contraints 

    /* TODO:
        The topic of JANNY FEATURES, if you wanted to run a platform for people to use but have the ability to janny ilegal streams and content you'd:
            Kick streamer []
                Want to be able to kick a streamer which is the easiest, hook up the kick streamer socket or janny socket event which would janny the stream with a message, or no message
            Kick watcher []
                The secondary way would be to also hook the janny event on the watcher's side (this part, so the broadcast id could be checked then jannied)

        P2P Chat []
            Enable it in stream view []
            Hook up markedjs client side []
            Hook up html sanitize []
            Hook up chat emotes []
            Persistent chat cache option client side []

        Bump audio quality settings into being for streaming [] This was working
        https://stackoverflow.com/questions/46063374/is-it-really-possible-for-webrtc-to-stream-high-quality-audio-without-noise

        applyConstraints seems to be what needs tracked down and then further backup the stack to find and set something similar to the ideal settings like these
        So looking at rs webrtc.js is in the webpack and has a bunch of stuff 

        (null
        connection.invokeGetUserMedia(null
        media(null
        options.onGettingLocalMedia(stream, returnBack);



        So it seems like all of invokeGetUserMedia(null are what need to be supplemented with more contraints to allow higher quality bitrates

        //default video contraints
    let videoConstraints = {
        height:     { ideal: 720},
        width :     { ideal: 1280},
        facingMode: { ideal: "environment" }
    }

    //default audio contraints
    let audioConstraints = {
        echoCancellation:   { ideal: false },
        autoGainControl: { ideal: false },
        googAutoGainControl: { ideal: false },
        googAutoGainControl2: { ideal: false },
        googExperimentalAutoGainControl: { ideal: false },
        googEchoCancellation: { ideal: false },
        googEchoCancellation2: { ideal: false },
        mozAutoGainControl: { ideal: false },

        channelCount: { ideal:2 },
        volume:{ ideal: 1.0 }
    }

    var localStream                 //local video elem
    var room;                       //protoo room
    var codec = 'VP8';              //codec force for better compatability

    //load volume if saved
    let volSlider = document.getElementById('volume-slider');
    if (localStorage.getItem("vid_volume") && volSlider) {
        console.log("loading saved volume from localStorage")
        var volumeConstraints = localStorage.getItem("vid_volume")/4;
        if (volumeConstraints > 1){volumeConstraints = 1}
        localRTCVideo.volume = volumeConstraints; 
        volSlider.value = volumeConstraints*400;
    }

    function volumeChange() {
        var volumeConstraints = this.value/400;
        if (volumeConstraints > 1){volumeConstraints = 1}
        localRTCVideo.volume = volumeConstraints; 
        localStorage.setItem("vid_volume", volumeConstraints * 4); 
      //because rick is going deaf and set the slider html range to 400%
        _util_js__WEBPACK_IMPORTED_MODULE_2__["muteState"](false);
    }
     Object.assign(audioConstraints, deviceIDinsert)

     https://webrtc.github.io/samples/src/content/peerconnection/bandwidth/
     a=rtpmap:111 opus/48000/2
     CodecsHandler
     https://github.com/webrtc/samples/blob/gh-pages/src/content/peerconnection/bandwidth/js/main.js
     https://github.com/webrtc/samples/blob/gh-pages/src/js/third_party/graph.js

     So to get the bandwdith for a connection you need to get the list of senders
     Then go through the first one's stats, then for each stat set, look at the report and how many bytes were sent


     const sender = pc1.getSenders()[0];
  if (!sender) {
    return;
  }
  sender.getStats().then(res => {
    res.forEach(report => {
      let bytes;
      let headerBytes;
      let packets;
      if (report.type === 'outbound-rtp') {
        if (report.isRemote) {
          return;
        }
        const now = report.timestamp;
        bytes = report.bytesSent;
        headerBytes = report.headerBytesSent;

        if (lastResult && lastResult.has(report.id)) {
          // calculate bitrate
          const bitrate = 8 * (bytes - lastResult.get(report.id).bytesSent) /
            (now - lastResult.get(report.id).timestamp);

        just keep and add the bytes sent as a running difference that needs updated every second

    */
    // channel=channelname

    function get(name){
   if(name=(new RegExp('[?&]'+encodeURIComponent(name)+'=([^&]*)')).exec(location.search))
        return decodeURIComponent(name[1]);
    }
    const chanval = get('channel');

    if(chanval){
        // set it in the join box
        document.getElementById('broadcast-id-slug').value = chanval;
    }

    // do early setup for a shared watch link to a specific stream
    var enableRecordings = false;
    
    let disable_stream_connect = true;
    

    var connection = new RTCMultiConnection();

    let vpn_info_org = "No vpn info yet...";
    let vpn_info_bound_org = "Will be the vpn that you want to find to, to check for a match";
    let vpn_info_ip = "no IP set";

    // https://www.rtcmulticonnection.org/docs/iceServers/
    // use your own TURN-server here!
    connection.iceServers = [];
    connection.iceServers.push({{{config.ICESERVER1}}});
    connection.iceServers.push({{{config.ICESERVER2}}});
    connection.iceServers.push({{{config.ICESERVER3}}});

    // its mandatory in v3
    connection.enableScalableBroadcast = true;

    // each relaying-user should serve only 1 users
    connection.maxRelayLimitPerUser = 1;

    // we don't need to keep room-opened
    // scalable-broadcast.js will handle stuff itself.
    connection.autoCloseEntireSession = true;

    connection.highbitratemodeaudio = true; // see if we can force it on and to sound better

    

    // by default, socket.io server is assumed to be deployed on your own URL
    connection.socketURL = "{{config.SIGSERVER}}";
    // this should be in the dotenv file and passed in as a template option
    //connection.socketURL = 'http://localhost:9001/';
    //connection.socketURL = 'https://muazkhan.com:9001/';

    // comment-out below line if you do not have your own socket.io server
    // connection.socketURL = 'https://rtcmulticonnection.herokuapp.com:443/';

    connection.socketMessageEvent = 'scalable-media-broadcast-demo';

    // document.getElementById('broadcast-id').value = connection.userid;

    // user need to connect server, so that others can reach him.
    connection.connectSocket(function(socket) {
        socket.on('logs', function(log) {
            //document.querySelector('h1').innerHTML = log.replace(/</g, '----').replace(/>/g, '___').replace(/----/g, '(<span style="color:red;">').replace(/___/g, '</span>)');
            console.log(log);
        });

        // this event is emitted when a broadcast is already created.
        socket.on('join-broadcaster', function(hintsToJoinBroadcast) {
            console.log('join-broadcaster', hintsToJoinBroadcast);

            connection.session = hintsToJoinBroadcast.typeOfStreams;
            connection.sdpConstraints.mandatory = {
                OfferToReceiveVideo: !!connection.session.video,
                OfferToReceiveAudio: !!connection.session.audio
            };
            connection.broadcastId = hintsToJoinBroadcast.broadcastId;
            connection.join(hintsToJoinBroadcast.userid);
        });

        socket.on('rejoin-broadcast', function(broadcastId) {
            console.log('rejoin-broadcast', broadcastId);

            connection.attachStreams = [];
            socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                if (!isBroadcastExists) {
                    // the first person (i.e. real-broadcaster) MUST set his user-id
                    connection.userid = broadcastId;
                }

                socket.emit('join-broadcast', {
                    broadcastId: broadcastId,
                    userid: connection.userid,
                    typeOfStreams: connection.session
                });
            });
        });

        socket.on('broadcast-stopped', function(broadcastId) {
            // alert('Broadcast has been stopped.');
            // location.reload();
            console.error('broadcast-stopped', broadcastId);
            //alert('This broadcast has been stopped.');
        });

        // this event is emitted when a broadcast is absent.
        /* This has been ommitted so you don't accidentally start a stream a s a viewer
        socket.on('start-broadcasting', function(typeOfStreams) {
            console.log('start-broadcasting', typeOfStreams);

            // host i.e. sender should always use this!
            connection.sdpConstraints.mandatory = {
                OfferToReceiveVideo: false,
                OfferToReceiveAudio: false
            };
            connection.session = typeOfStreams;

            // "open" method here will capture media-stream
            // we can skip this function always; it is totally optional here.
            // we can use "connection.getUserMediaHandler" instead
            connection.open(connection.userid);
        });
        */
    });

    window.onbeforeunload = function() {
        // Firefox is ugly.
        document.getElementById('open-or-join').disabled = false;
    };

    var videoPreview = document.getElementById('video-preview');

    connection.onstream = function(event) {
        if (connection.isInitiator && event.type !== 'local') {
            return;
        }

        connection.isUpperUserLeft = false;
        videoPreview.srcObject = event.stream;
        try{
            videoPreview.play();
            document.getElementById("topinfovideo").hidden = true;
        }catch(error){
            console.log("There was an error auto playing, you probably need to manually click play");
        }

        videoPreview.userid = event.userid;

        if (event.type === 'local') {
            videoPreview.muted = true;
        }

        if (connection.isInitiator == false && event.type === 'remote') {
            // he is merely relaying the media
            connection.dontCaptureUserMedia = true;
            connection.attachStreams = [event.stream];
            connection.sdpConstraints.mandatory = {
                OfferToReceiveAudio: false,
                OfferToReceiveVideo: false
            };

            connection.getSocket(function(socket) {
                socket.emit('can-relay-broadcast');

                if (connection.DetectRTC.browser.name === 'Chrome') {
                    connection.getAllParticipants().forEach(function(p) {
                        if (p + '' != event.userid + '') {
                            /* this is the old chrome replace track should do all of this?
                            var peer = connection.peers[p].peer;
                            peer.getLocalStreams().forEach(function(localStream) {
                                peer.removeStream(localStream);
                            });
                            event.stream.getTracks().forEach(function(track) {
                                peer.addTrack(track, event.stream);
                            });
                            connection.dontAttachStream = true;
                            connection.renegotiate(p);
                            connection.dontAttachStream = false;
                            */

                            connection.replaceTrack(event.stream, p);
                        }
                    });
                }

                if (connection.DetectRTC.browser.name === 'Firefox') {
                    // Firefox is NOT supporting removeStream method
                    // that's why using alternative hack.
                    // NOTE: Firefox seems unable to replace-tracks of the remote-media-stream
                    // need to ask all deeper nodes to rejoin
                    connection.getAllParticipants().forEach(function(p) {
                        if (p + '' != event.userid + '') {
                            connection.replaceTrack(event.stream, p);
                        }
                    });
                }

                // Firefox seems UN_ABLE to record remote MediaStream
                // WebAudio solution merely records audio
                // so recording is skipped for Firefox.
                if (connection.DetectRTC.browser.name === 'Chrome') {
                    repeatedlyRecordStream(event.stream);
                }
            });
        }

        // to keep room-id in cache
        localStorage.setItem(connection.socketMessageEvent, connection.sessionid);
    };

    // ask node.js server to look for a broadcast
    // if broadcast is available, simply join it. i.e. "join-broadcaster" event should be emitted.
    // if broadcast is absent, simply create it. i.e. "start-broadcasting" event should be fired.
    /* This needs to be hooked up to fire using the buttons in the streamer list */
    document.getElementById('open-or-join').onclick = function() {
        var broadcastId = document.getElementById('broadcast-id').value;
        if (broadcastId.replace(/^\s+|\s+$/g, '').length <= 0) {
            alert('Please enter broadcast-id');
            document.getElementById('broadcast-id').focus();
            return;
        }

        document.getElementById('open-or-join').disabled = true;

        connection.extra.broadcastId = broadcastId;

        connection.session = {
            audio: true,
            video: true,
            oneway: true
        };

        connection.getSocket(function(socket) {
            socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                if (!isBroadcastExists) {
                    // the first person (i.e. real-broadcaster) MUST set his user-id
                    connection.userid = broadcastId;
                }

                console.log('check-broadcast-presence', broadcastId, isBroadcastExists);

                socket.emit('join-broadcast', {
                    broadcastId: broadcastId,
                    userid: connection.userid,
                    typeOfStreams: connection.session
                });
            });
        });
    };

    document.getElementById('join').onclick = function() {
        var broadcastId = document.getElementById('broadcast-id-slug').value;
        if (broadcastId.replace(/^\s+|\s+$/g, '').length <= 0) {
            alert('Please enter broadcast-id');
            document.getElementById('broadcast-id-slug').focus();
            return;
        }

        document.getElementById('join').disabled = true;

        connection.extra.broadcastId = broadcastId;

        connection.session = {
            audio: true,
            video: true,
            oneway: true
        };

        connection.getSocket(function(socket) {
            socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                if (!isBroadcastExists) {
                    // the first person (i.e. real-broadcaster) MUST set his user-id
                    //connection.userid = broadcastId;
                    console.log("Stream not live!");
                    alert("Stream not live :(");

                }else{

                    console.log('check-broadcast-presence', broadcastId, isBroadcastExists);

                    socket.emit('join-broadcast', {
                        broadcastId: broadcastId,
                        userid: connection.userid,
                        typeOfStreams: connection.session
                    });
                }
            });
        });
    };
    

    connection.onstreamended = function() {};

    connection.onleave = function(event) {
        if (event.userid !== videoPreview.userid) return;

        connection.getSocket(function(socket) {
            socket.emit('can-not-relay-broadcast');

            connection.isUpperUserLeft = true;

            if (allRecordedBlobs.length) {
                // playing lats recorded blob
                var lastBlob = allRecordedBlobs[allRecordedBlobs.length - 1];
                videoPreview.src = URL.createObjectURL(lastBlob);
                videoPreview.play();
                allRecordedBlobs = [];
            } else if (connection.currentRecorder) {
                var recorder = connection.currentRecorder;
                connection.currentRecorder = null;
                recorder.stopRecording(function() {
                    if (!connection.isUpperUserLeft) return;

                    videoPreview.src = URL.createObjectURL(recorder.getBlob());
                    videoPreview.play();
                });
            }

            if (connection.currentRecorder) {
                connection.currentRecorder.stopRecording();
                connection.currentRecorder = null;
            }
        });
    };

    var allRecordedBlobs = [];

    function repeatedlyRecordStream(stream) {
        if (!enableRecordings) {
            return;
        }

        connection.currentRecorder = RecordRTC(stream, {
            type: 'video'
        });

        connection.currentRecorder.startRecording();

        setTimeout(function() {
            if (connection.isUpperUserLeft || !connection.currentRecorder) {
                return;
            }

            connection.currentRecorder.stopRecording(function() {
                allRecordedBlobs.push(connection.currentRecorder.getBlob());

                if (connection.isUpperUserLeft) {
                    return;
                }

                connection.currentRecorder = null;
                repeatedlyRecordStream(stream);
            });
        }, 30 * 1000); // 30-seconds
    };

    function disableInputButtons() {
        document.getElementById('open-or-join').disabled = true;
        document.getElementById('broadcast-id').disabled = true;
    }

    // ......................................................
    // ......................Handling broadcast-id................
    // ......................................................

      /*var broadcastId = '';
    if (localStorage.getItem(connection.socketMessageEvent)) {
        broadcastId = localStorage.getItem(connection.socketMessageEvent);
    } else {
        broadcastId = connection.token();
    }
    var txtBroadcastId = document.getElementById('broadcast-id');
    txtBroadcastId.value = broadcastId;
    txtBroadcastId.addClass('hide');
    txtBroadcastId.onkeyup = txtBroadcastId.oninput = txtBroadcastId.onpaste = function() {
        localStorage.setItem(connection.socketMessageEvent, this.value);
    };*/

    // below section detects how many users are viewing your broadcast

    connection.onNumberOfBroadcastViewersUpdated = function(event) {
        if (!connection.isInitiator) return;

        document.getElementById('broadcast-viewers-counter').innerHTML = 'Number of broadcast viewers: <b>' + event.numberOfBroadcastViewers + '</b>';
    };

    // connect and get live stream list
    // livestreams needs to be cleared then have the list updated
    let socketlc = io.connect(window.location.origin, { transports: ['websocket'] });
    let usertoken = "";

    socketlc.on('connect', () => {
        load_chatToken();
        socketlc.emit('new user', {jwt:usertoken});

        socketlc.emit('getlivestreams');
        console.log("User connected!");
        
    });

    socketlc.on('livestreams', (data)=>{
        console.log("We should have a list stream list to update the UI:",data);
        updateStreamList(data.streams);
    });

    function doHLSp2p(streaminfo){
        console.log("Should connect to:",streaminfo);
        // get the url/src/type
        // streaminfo.src = data.src;
        // streaminfo.type = "application/x-mpegURL";
        // so one of the problems is the video doesn't fill the container and sets the height to 0
             if (p2pml.hlsjs.Engine.isSupported()) {
                    var engine = new p2pml.hlsjs.Engine();

                    var player = new Clappr.Player({
                        //parentId: "#player",
                        parentId: "#video-container",
                        source: streaminfo.src,
                        mute: false,
                        autoPlay: true,
                        height: "100%",
                        width: "100%",
                        playback: {
                            hlsjsConfig: {
                                liveSyncDurationCount: 7,
                                loader: engine.createLoaderClass()
                            }
                        }
                    });

                    p2pml.hlsjs.initClapprPlayer(player);
                } else {
                    document.write("Not supported :(");
                }
            


                //data-setup='{&quot;aspectRatio&quot;:&quot;16:9&quot;}'
                // https://www.watch2gether.com/
            
    }

    function doStreamConnect(streamid){
        /*var broadcastId = document.getElementById('broadcast-id').value;
        if (broadcastId.replace(/^\s+|\s+$/g, '').length <= 0) {
            alert('Please enter broadcast-id');
            document.getElementById('broadcast-id').focus();
            return;
        }*/

        
        
        //document.getElementById("topinfovideo"). = true;


        connection.setHighBitrateModeAudio(true); // This should be used with a checkbox to configure if the stream should be high bitrate on the streamer side so it can be configured, automatically via config on the clients side
        disable_stream_connect = false;
        document.getElementById("livestreams").disabled = true;

        document.getElementById('open-or-join').disabled = true;
        let broadcastId = streamid;
        connection.extra.broadcastId = broadcastId;

        connection.session = {
            audio: true,
            video: true,
            oneway: true
        };

        connection.getSocket(function(socket) {
            socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                if (!isBroadcastExists) {
                    // the first person (i.e. real-broadcaster) MUST set his user-id
                    //connection.userid = broadcastId;
                }

                console.log('check-broadcast-presence', broadcastId, isBroadcastExists);
                if (isBroadcastExists) {
                    socket.emit('join-broadcast', {
                        broadcastId: broadcastId,
                        userid: connection.userid,
                        typeOfStreams: connection.session
                    });
                }else{
                    //alert("Stream is offline!");
                    console.log("Stream is now offline!");
                    disable_stream_connect = true;
                }
            });
        });
    }

    function updateStreamList(streams){
        // clear the streamer list
        $("#livestreams").empty();
        streams.forEach(stream => {

            if(stream.live){
        let node = document.createElement("div"); 
            
            let textnodeAvatar = document.createElement("avatar");
                
                
                textnodeAvatar.classList.add("avatar");
            
                textnodeAvatar.innerHTML = "<img class=\"userav\" src=\"{{config.TROLLICON}}\" style=\"background: rgb(32, 99, 223);\">";
                if(stream.avatar){
                    textnodeAvatar.innerHTML = "<img class=\"userav\" src=\"" + stream.avatar + "\" style=\"background: rgb(32, 99, 223);\">";
                }
                
                textnodeAvatar.addEventListener('click', function(e){
                    // do something
                    /*let atmessage = $("textarea#message").val()
                        atmessage += "@" + user + " ";
                        $("textarea#message").val(atmessage)
                        $("textarea#message").focus();// send focus back to chat
                    }*/
                    document.getElementById("topinfovideo").hidden = true;
                    console.log("Should attempt to connect to stream!",stream.user, stream.desc);
                    if(disable_stream_connect){
                        //doStreamConnect(stream.user); // this has been disabled and the video player container has been removed...
                        doHLSp2p(stream);
                    }
                });
                node.appendChild(textnodeAvatar); 

                let textnodep2p = document.createElement("p2p");
                textnodep2p.addEventListener('click', function(e){
                    // do something
                    /*let atmessage = $("textarea#message").val()
                        atmessage = "!w " + user + " " + atmessage;
                        $("textarea#message").val(atmessage)
                        $("textarea#message").focus();// send focus back to chat
                    }*/
                    document.getElementById("topinfovideo").hidden = true;
                    console.log("Should attempt to connect to stream!",stream.user, stream.desc);
                    if(disable_stream_connect){
                        doHLSp2p(stream);
                    }
                });

                textnodep2p.innerHTML = '<span style=" color: white;">HLSP2P</span>';


                let textnodeUserName = document.createElement("username"); // need to add a on click event for the attribute
                // need to add a onclick for username_click(el.username)
                textnodeUserName.addEventListener('click', function(e){
                    // do something
                    /*let atmessage = $("textarea#message").val()
                        atmessage = "!w " + user + " " + atmessage;
                        $("textarea#message").val(atmessage)
                        $("textarea#message").focus();// send focus back to chat
                    }*/
                    document.getElementById("topinfovideo").hidden = true;
                    console.log("Should attempt to connect to stream!",stream.user, stream.desc);
                    if(disable_stream_connect){
                        //doStreamConnect(stream.user);
                        doHLSp2p(stream);
                    }
                });
                
                textnodeUserName.innerHTML = '<span style=" color: white;">' + stream.user + "-" + stream.desc + ' Viewers: ' + stream.viewCount + ' RTC Viewers:' + stream.viewCountRTC  +'</span>'; 
                
                
                
                node.appendChild(textnodeUserName);  

                node.appendChild(textnodep2p);  // add the p2p option
                
                //let textnode = document.createElement("message");
                //textnode.innerHTML = "<p>Ignore Toggle</p>"; 
                
                //node.appendChild(textnode); 

                document.getElementById("livestreams").appendChild(node);
                let nodebr = document.createElement("br"); 
                //document.getElementById("thewatchers").appendChild(nodebr);
                //document.getElementById("thewatchers").appendChild(nodebr);
                document.getElementById("livestreams").appendChild(nodebr);
             }// matches the live check, only adds them if they are live
        }); // end of for each stream/user
    }

    function parseToken (token) {
        try{
            var base64Url = token.split('.')[1];
            var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            var jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
        }catch(ex){
            console.log("failed to parse the token")
            return {user:{name:'failed'}}
        }
        return JSON.parse(jsonPayload);
    };

    function load_chatToken(){
        try {
            if(window.localStorage.chatToken){
                usertoken = window.localStorage.getItem('chatToken');
                //const temptoken = JSON.parse(usertoken);
                //console.log("My token loade:",temptoken);

                const usernametemp = parseToken(usertoken).sub.username;
                
                // this allows connections to be identified by their token name turned off to make it harder to ip scrape
                //document.getElementById('broadcast-id').value = usernametemp;
                //connection.userid = usernametemp;


                //const usernametemp = parseToken(usertoken).sub.username;
                //username_global = usernametemp;
                //$("#userid").val(usernametemp);
                return;
            }else{
                if(window.localStorage.trollToken){
                    load_trollToken();
                }else{
                    load_trollToken();
                }
            }

        }catch(ex){

        }
    }

    function load_trollToken(){
        try {
            if(window.localStorage.trollToken){
                usertoken = window.localStorage.getItem('trollToken');
                const usernametemp = parseToken(usertoken).sub.username;
                // disabled to be somewhat anon
                //document.getElementById('broadcast-id').value = usernametemp;
                //connection.userid = usernametemp;
                return;
            }else{
                mktroll();

                return;
            }

        }catch(ex){
            
        }
    }

    function mktroll(){
        const endpoint = '/mktroll';
                $.get( endpoint, function(data, status){
                    
                    if(status == "success"){
                        console.log("data:",data);
                        window.localStorage.setItem('trollToken'  , data  );
                        //load_chatToken();
                        load_trollToken();
                        //window.location.reload();
                    }
                });
    }

    // this should be hooked to a browser event every time the internet connection goes to online as well
    function getMyIp(){
        try{
            document.getElementById('ipinfo').innerText = "Error getting ip, check that popup blocker and ad blockers are disabled for this domain/page...";
      $.get('https://ipinfo.io', (response) => {
        console.log("ipinfo.io your public ip is:", response.ip);
        console.log("Full response:",response);
        vpn_info_org = response.org;
        vpn_info_ip = response.ip;
        //"org": "AS62240 Clouvider",
        // should be locked to the provider identified and warn if they do not match and show the new one
        document.getElementById('ipinfo').innerText = "Your public IP is: " + vpn_info_ip + " Your provider is detected as: " + vpn_info_org;

      },'json');
      }catch(error){
          console.log("Error checking ip info, check popup blocker extension on the site...");
            
            document.getElementById('ipinfo').innerText = "Error getting ip, check that popup blocker and ad blockers are disabled for this domain/page";
      }

       /*$.getJSON("http://jsonip.com/?callback=?", function (data) {
        console.log('jsonip.com your public ip is',data);
        //alert(data.ip);
        // https://cleantalk.org/blacklists/ip
        // https://ipinfo.io/AS212238/IP/subnetbits
        // curl -v https://ipinfo.io
        });*/
    }

    if(chanval){
        console.log("Trying to connect to the stream...",chanval );
        doStreamConnect(chanval);
    }

    </script>
