    <meta charset="utf-8">
    <title>FedWave</title>
    <!-- link to jquery 2.0 <script src="js/jquery-2.0.0.js"></script> -->
    <script src="/socket.io/socket.io.js"></script>
    <script
			  src="https://code.jquery.com/jquery-2.2.4.min.js"
			  integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44="
			  crossorigin="anonymous"></script>
    <!-- link to bootstrap 2.3.1 <script src="js/bootstrap.js"></script>  -->
    <script src="https://cdn.usebootstrap.com/bootstrap/2.3.2/js/bootstrap.min.js"></script>
    <!--<link href="css/bootstrap.css" rel="stylesheet">-->
    <link href="https://cdn.usebootstrap.com/bootstrap/2.3.2/css/bootstrap.min.css" rel="stylesheet">
    
    <link href="/bs.css" rel="stylesheet">
    <style>
      
        .labelhelper{
            
            color: #789922;
        }
    
       .avatar{
            float: left;
            width: 34px;
            height: 34px;
            
        }
    

    
    body{background-color:#2f2f2f}
    </style>

    <div class="labelhelper">
        Watch live streams happening right NOW!
        <p class="no-mobile">
        Use peer-to-peer protocol to broadcast your video over 20+ users.
        Maybe have a stream slug handler to watch a specific user
        </p>
        <div><li>Are you using a vpn?</li><li>Are you sure you are using a vpn?</li><li>Are you really sure you are using a vpn?</li></div>
        <div id="ipinfo" onclick="getMyIp()">Click to check IP info...</div>
  </div>
    <section class="make-center">
      <p style="margin: 0; padding: 0; padding-bottom: 20px;">
          <div class="make-center">
              <!-- This should be replaced by a user list of live streams -->
                    <input class="hide" type="text" id="broadcast-id" value="room-xyz" autocorrect=off autocapitalize=off size=20>
                    <button class="hide" id="open-or-join">Open or Join Broadcast</button>
                
            <div id="livestreams">

            </div>
          <div class="make-center" id="broadcast-viewers-counter"></div>
      </p>
        <div id="video-container">
        <video id="video-preview" controls ></video>
       
        <div id="video-controls">
            <button type="button" id="play-pause">Play</button>
            <!---<input type="range" id="seek-bar" value="0">-->
            <button type="button" id="mute">Mute</button>
            <input type="range" id="volume-bar" min="0" max="1" step="0.1" value="1">
            <button type="button" id="full-screen">Full-Screen</button>
            <!---
            <button type="button" id="vidmute">Video Mute</button>
            <button type="button" id="audmute" onclick="hookAudio">Audio Mute</button>-->
        </div>
    </div>
    <!---
     <audio id="preview-audio" controls></audio>
     -->
        <div class="graph-container" id="bitrateGraph">
            <div>Bitrate</div>
            <canvas id="bitrateCanvas"></canvas>
        </div>

        <input type="text" id="broadcast-id-slug" value="room-xyz#1234" autocorrect=off autocapitalize=off size=20>
        <button id="join">Join Broadcast</button>
  </section>
    <style>
        video {
            width: 95%;
        }
        button, input, select {
            font-family: Myriad, Arial, Verdana;
            font-weight: normal;
            border-top-left-radius: 3px;
            border-top-right-radius: 3px;
            border-bottom-right-radius: 3px;
            border-bottom-left-radius: 3px;
            padding: 4px 12px;
            text-decoration: none;
            color: rgb(27, 26, 26);
            display: inline-block;
            box-shadow: rgb(255, 255, 255) 1px 1px 0px 0px inset;
            text-shadow: none;
            background: -webkit-gradient(linear, 0% 0%, 0% 100%, color-stop(0.05, rgb(241, 241, 241)), to(rgb(230, 230, 230)));
            font-size: 20px;
            border: 1px solid red;
            outline:none;
        }
        button:active, input:active, select:active, button:focus, input:focus, select:focus {
            background: -webkit-gradient(linear, 0% 0%, 0% 100%, color-stop(5%, rgb(221, 221, 221)), to(rgb(250, 250, 250)));
            border: 1px solid rgb(142, 142, 142);
        }
        button[disabled], iput[disabled], select[disabled] {
            background: rgb(249, 249, 249);
            border: 1px solid rgb(218, 207, 207);
            color: rgb(197, 189, 189);
        }
        input, input:focus, input:active {
            background: white;    
        }
    </style>

    <script>
        // https://www.reddit.com/r/WebRTC/comments/hlr5fc/is_it_possible_to_control_volume_per_audio_track/
        // Need a global gain control that all tracks get connected to, or at least the remote stream (being sent) gets connected to and set to -100 or -1 gain to mute it
        //const gainNode = audioContext.createGain();
        // GainNode
        // look at connection.applyConstraints(newconstraings,stream)
        // https://webrtc.org/getting-started/media-capture-and-constraints
        // https://webrtc.org/getting-started/remote-streams

        //=fmtp:109 maxplaybackrate=48000;stereo=1;useinbandfec=1
        // https://blog.teamtreehouse.com/building-custom-controls-for-html5-videos

        // https://www.inwebson.com/html5/custom-html5-video-controls-with-jquery/

        //const audioContext = new AudioContext();
        //const gainNode = audioContext.createGain();
        //let audioNode = null; //audioContext.createMediaStreamSource();

        // the problem seems to be with the tracks and streams and how they get hooked

        // make a URL slug to start watching the stream or request the stream

        // https://web.dev/webaudio-intro/
        // https://gabrieltanner.org/blog/turn-server/

        // add a high bitrate option

        // so the audio works as expected now, we have an option to select the audio high bitrate

        // now to fix the chrome crashing bug,anything that is a direct chrome core will cause it to crash when another one connects
        // to someone that is using chrome, so chromium, brave, chrome all cause crashing, might be based on the user agent
        // Error code: SIGILL is the error I get in both versions

        // need to also debug how to reconnect and setup a room as the streamer if the server restarts

        function hookAudio(){
            //"preview-audio"
            let audioElem = document.getElementById("preview-audio");
            audioElem.srcObject = connection.attachStreams[0].getTracks()[0];
            window.audioContext = new AudioContext();
            window.gainNode = window.audioContext.createGain();
            //window.gainNode.connect(this.incomingMedia);
            window.audioNode = window.audioContext.createMediaStreamSource(remoteStream);
            window.audioNode.connect(window.gainNode);
            window.audioContext.resume();
            // connection.peers['Playlistbot9k'].streams[0].getTracks()
            // connection.peers['Playlistbot9k'].streams[0].getAudioTracks()[0].enabled = true;
        }


        function muteAudio(){
            connection.attachStreams[0].getTracks()[0].enabled = true;
            connection.attachStreams[0].getTracks()[0].muted = true;
        }
        

        function muteVideo(){
            connection.streamEvents.selectFirst('local').mute('video');
            connection.streamEvents.selectFirst('local').getTracks()[0].enabled = true; // i.e. manually enable audio track after

                connection.streamEvents.selectFirst('local').getTracks()[1].enabled = false; // it will disable only video track
            connection.send({
                myVideoTrackIsMuted: true,
                trackId: connection.streamEvents.selectFirst('local').getTracks()[1].id,
                streamId: connection.streamEvents.selectFirst('local').id
            });

            connection.onmessage = function(event) {
                if(event.data.myVideoTrackIsMuted === true) {
                    document.getElementById(event.data.streamId).pause(); // you can set "srcObject=null" or removeAttribute('srcObject')
                    document.getElementById(event.data.streamId).poster = '/images/poster.png'; // or background image
                }
            };
        }
        

            // Video
            var video = document.getElementById("video-preview");

            // Buttons
            var playButton = document.getElementById("play-pause");
            var muteButton = document.getElementById("mute");
            var fullScreenButton = document.getElementById("full-screen");

            // Sliders
            //var seekBar = document.getElementById("seek-bar");
            var volumeBar = document.getElementById("volume-bar");

            


            // Event listener for the play/pause button
            playButton.addEventListener("click", function() {
            if (video.paused == true) {
                // Play the video
                video.play();

                // Update the button text to 'Pause'
                playButton.innerHTML = "Pause";
            } else {
                // Pause the video
                video.pause();

                // Update the button text to 'Play'
                playButton.innerHTML = "Play";
            }
            });

            // Event listener for the mute button
            muteButton.addEventListener("click", function() {
            if (video.muted == false) {
                // Mute the video
                video.muted = true;

                // Update the button text
                muteButton.innerHTML = "Unmute";
            } else {
                // Unmute the video
                video.muted = false;

                // Update the button text
                muteButton.innerHTML = "Mute";
            }
            });


            // Event listener for the full-screen button
            fullScreenButton.addEventListener("click", function() {
            if (video.requestFullscreen) {
                video.requestFullscreen();
            } else if (video.mozRequestFullScreen) {
                video.mozRequestFullScreen(); // Firefox
            } else if (video.webkitRequestFullscreen) {
                video.webkitRequestFullscreen(); // Chrome and Safari
            }
            });

            // Event listener for the volume bar
            volumeBar.addEventListener("change", function() {
                // Update the video volume
                video.volume = volumeBar.value;
                console.log("New volume set for the video: ",volumeBar.value);
                // now what would be nice is to have an audio track mute or something to hook the audio track up to the control
            });

            // going to leave out the seek bar since you can't seek a webrtc track stream without a local cache
    </script>

    <script src="/RTCMultiConnection.js"></script>
    <script>

        //connection.peers[remoteUserId].peer.lastAudioTrack = rtpSender.track;
                        //rtpSender.replaceTrack(track);
        // Cool so everyone thinks that muaz is dead
        // so would be a potential replacement https://github.com/feross/simple-peer
        // hls rtmp cnd wrtc https://github.com/cdnbye/hlsjs-p2p-engine
        // https://web.dev/webrtc-basics/
        // connection.peers['peerid'].peer.getLocalStreams()[0] type: 'remote' is the one that goes to the next client in the chain
        // streamid: "{43744dfa-8600-487a-b8b9-814dcc4c3856}"
        // streamsToShare
        // allRemoteStreams

        // https://stackoverflow.com/questions/27908408/webrtc-how-to-mute-local-audio-output#44141610

        // https://webrtc.github.io/samples/
        // audio level https://github.com/webrtc/samples/tree/gh-pages/src/content/getusermedia/volume

        // https://muazkhan.com:9001/demos/Scalable-Broadcast.html
        // https://github.com/muaz-khan/WebRTC-Scalable-Broadcast
        // https://github.com/muaz-khan/WebRTC-Scalable-Broadcast/blob/master/WebRTC-Scalable-Broadcast.js
        // https://github.com/muaz-khan/WebRTC-Scalable-Broadcast/blob/master/RTCMultiConnection.js
        // https://programmer.help/blogs/automatic-audio-gain-and-mute-detection-algorithms-with-complete-c-code.html

        // connection.peers["peerid"].peer.getSenders()[0].track.enabled = true; // now the problem with doing a mute on the track is that it kill the down stream audio
        // https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings volume, might need to be set to 0 for the remote track that is being sent out?
        // https://github.com/muaz-khan/WebRTC-Experiment/issues/663
        // have a local clipping buffer that gives you a minute or 30 seconds that the user can adjust, so they can save and clip the local files
        // Then the fun would be ipfs js client in browser to help share the clip or use webtorrent + magnet link for file/clip sharing
        // add api for user clip sharing list, so you can query all users and see what the clips are named in a p2p way
        // https://github.com/muaz-khan/RTCMultiConnection/issues/1030
        // add audio only option for clients so they end up in the audio only chain
        // https://github.com/eelcocramer/webrtc-mp3-stream/blob/master/client/index.html

        // https://developer.mozilla.org/en-US/docs/Web/API/GainNode is probably needed to be applied to the relay stream
        // https://stackoverflow.com/questions/62744471/webrtc-is-it-possible-to-control-volume-per-audio-track-when-we-have-audio-stre#62745356

        // server side: https://github.com/muaz-khan/WebRTC-Scalable-Broadcast/blob/master/WebRTC-Scalable-Broadcast.js
    // recording is disabled because it is resulting for browser-crash
    // if you enable below line, please also uncomment above "RecordRTC.js"
    // https://github.com/muaz-khan/RTCMultiConnection/tree/master/demos/SSEConnection
    // https://www.rtcmulticonnection.org/docs/getting-started/
    // has a nice chat demo connection.send('hello everyone');
    // and then 
    /*
        // if you want text chat
        connection.session = {
            data: true
        };
        connection.onmessage = function(event) {
            alert(event.userid + ' said: ' + event.data);
        };
        connection.openOrJoin('your-room-id');
    */
    // chat height should match the video height and be hidden until shown by the video
    // the question is... is it p2p or socketio that it goes over

    // https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/autoGainControl
    // applyConstraints seems to be what I'm looking for, then when the other use connects, the stream id for the audio track needs to have the gain control set and added
    // so it can be set to zero?
    // mediaConstraints.audio
    // https://developer.mozilla.org/en-US/docs/Web/API/Media_Capture_and_Streams_API/Constraints#example__constraint_exerciser
    // function applyConstraints exposes track and contraints 

    /* TODO:
        The topic of JANNY FEATURES, if you wanted to run a platform for people to use but have the ability to janny ilegal streams and content you'd:
            Kick streamer []
                Want to be able to kick a streamer which is the easiest, hook up the kick streamer socket or janny socket event which would janny the stream with a message, or no message
            Kick watcher []
                The secondary way would be to also hook the janny event on the watcher's side (this part, so the broadcast id could be checked then jannied)

        P2P Chat []
            Enable it in stream view []
            Hook up markedjs client side []
            Hook up html sanitize []
            Hook up chat emotes []
            Persistent chat cache option client side []

        Bump audio quality settings into being for streaming [] This was working
        https://stackoverflow.com/questions/46063374/is-it-really-possible-for-webrtc-to-stream-high-quality-audio-without-noise

        applyConstraints seems to be what needs tracked down and then further backup the stack to find and set something similar to the ideal settings like these
        So looking at rs webrtc.js is in the webpack and has a bunch of stuff 

        (null
        connection.invokeGetUserMedia(null
        media(null
        options.onGettingLocalMedia(stream, returnBack);



        So it seems like all of invokeGetUserMedia(null are what need to be supplemented with more contraints to allow higher quality bitrates

        //default video contraints
    let videoConstraints = {
        height:     { ideal: 720},
        width :     { ideal: 1280},
        facingMode: { ideal: "environment" }
    }

    //default audio contraints
    let audioConstraints = {
        echoCancellation:   { ideal: false },
        autoGainControl: { ideal: false },
        googAutoGainControl: { ideal: false },
        googAutoGainControl2: { ideal: false },
        googExperimentalAutoGainControl: { ideal: false },
        googEchoCancellation: { ideal: false },
        googEchoCancellation2: { ideal: false },
        mozAutoGainControl: { ideal: false },

        channelCount: { ideal:2 },
        volume:{ ideal: 1.0 }
    }

    var localStream                 //local video elem
    var room;                       //protoo room
    var codec = 'VP8';              //codec force for better compatability

    //load volume if saved
    let volSlider = document.getElementById('volume-slider');
    if (localStorage.getItem("vid_volume") && volSlider) {
        console.log("loading saved volume from localStorage")
        var volumeConstraints = localStorage.getItem("vid_volume")/4;
        if (volumeConstraints > 1){volumeConstraints = 1}
        localRTCVideo.volume = volumeConstraints; 
        volSlider.value = volumeConstraints*400;
    }

    function volumeChange() {
        var volumeConstraints = this.value/400;
        if (volumeConstraints > 1){volumeConstraints = 1}
        localRTCVideo.volume = volumeConstraints; 
        localStorage.setItem("vid_volume", volumeConstraints * 4); 
      //because rick is going deaf and set the slider html range to 400%
        _util_js__WEBPACK_IMPORTED_MODULE_2__["muteState"](false);
    }
     Object.assign(audioConstraints, deviceIDinsert)

     https://webrtc.github.io/samples/src/content/peerconnection/bandwidth/
     a=rtpmap:111 opus/48000/2
     CodecsHandler
     https://github.com/webrtc/samples/blob/gh-pages/src/content/peerconnection/bandwidth/js/main.js
     https://github.com/webrtc/samples/blob/gh-pages/src/js/third_party/graph.js

     So to get the bandwdith for a connection you need to get the list of senders
     Then go through the first one's stats, then for each stat set, look at the report and how many bytes were sent


     const sender = pc1.getSenders()[0];
  if (!sender) {
    return;
  }
  sender.getStats().then(res => {
    res.forEach(report => {
      let bytes;
      let headerBytes;
      let packets;
      if (report.type === 'outbound-rtp') {
        if (report.isRemote) {
          return;
        }
        const now = report.timestamp;
        bytes = report.bytesSent;
        headerBytes = report.headerBytesSent;

        if (lastResult && lastResult.has(report.id)) {
          // calculate bitrate
          const bitrate = 8 * (bytes - lastResult.get(report.id).bytesSent) /
            (now - lastResult.get(report.id).timestamp);

        just keep and add the bytes sent as a running difference that needs updated every second

    */
    // channel=channelname

    function get(name){
   if(name=(new RegExp('[?&]'+encodeURIComponent(name)+'=([^&]*)')).exec(location.search))
        return decodeURIComponent(name[1]);
    }
    const chanval = get('channel');

    if(chanval){
        // set it in the join box
        document.getElementById('broadcast-id-slug').value = chanval;
    }

    // do early setup for a shared watch link to a specific stream
    var enableRecordings = false;
    
    let disable_stream_connect = true;
    

    var connection = new RTCMultiConnection();

    let vpn_info_org = "No vpn info yet...";
    let vpn_info_bound_org = "Will be the vpn that you want to find to, to check for a match";
    let vpn_info_ip = "no IP set";

    // https://www.rtcmulticonnection.org/docs/iceServers/
    // use your own TURN-server here!
    connection.iceServers = [];
    connection.iceServers.push({{{config.ICESERVER1}}});
    connection.iceServers.push({{{config.ICESERVER2}}});
    connection.iceServers.push({{{config.ICESERVER3}}});

    // its mandatory in v3
    connection.enableScalableBroadcast = true;

    // each relaying-user should serve only 1 users
    connection.maxRelayLimitPerUser = 1;

    // we don't need to keep room-opened
    // scalable-broadcast.js will handle stuff itself.
    connection.autoCloseEntireSession = true;

    connection.highbitratemodeaudio = true; // see if we can force it on and to sound better

    // by default, socket.io server is assumed to be deployed on your own URL
    connection.socketURL = "{{config.SIGSERVER}}";
    // this should be in the dotenv file and passed in as a template option
    //connection.socketURL = 'http://localhost:9001/';
    //connection.socketURL = 'https://muazkhan.com:9001/';

    // comment-out below line if you do not have your own socket.io server
    // connection.socketURL = 'https://rtcmulticonnection.herokuapp.com:443/';

    connection.socketMessageEvent = 'scalable-media-broadcast-demo';

    // document.getElementById('broadcast-id').value = connection.userid;

    // user need to connect server, so that others can reach him.
    connection.connectSocket(function(socket) {
        socket.on('logs', function(log) {
            //document.querySelector('h1').innerHTML = log.replace(/</g, '----').replace(/>/g, '___').replace(/----/g, '(<span style="color:red;">').replace(/___/g, '</span>)');
            console.log(log);
        });

        // this event is emitted when a broadcast is already created.
        socket.on('join-broadcaster', function(hintsToJoinBroadcast) {
            console.log('join-broadcaster', hintsToJoinBroadcast);

            connection.session = hintsToJoinBroadcast.typeOfStreams;
            connection.sdpConstraints.mandatory = {
                OfferToReceiveVideo: !!connection.session.video,
                OfferToReceiveAudio: !!connection.session.audio
            };
            connection.broadcastId = hintsToJoinBroadcast.broadcastId;
            connection.join(hintsToJoinBroadcast.userid);
        });

        socket.on('rejoin-broadcast', function(broadcastId) {
            console.log('rejoin-broadcast', broadcastId);

            connection.attachStreams = [];
            socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                if (!isBroadcastExists) {
                    // the first person (i.e. real-broadcaster) MUST set his user-id
                    connection.userid = broadcastId;
                }

                socket.emit('join-broadcast', {
                    broadcastId: broadcastId,
                    userid: connection.userid,
                    typeOfStreams: connection.session
                });
            });
        });

        socket.on('broadcast-stopped', function(broadcastId) {
            // alert('Broadcast has been stopped.');
            // location.reload();
            console.error('broadcast-stopped', broadcastId);
            //alert('This broadcast has been stopped.');
        });

        // this event is emitted when a broadcast is absent.
        /* This has been ommitted so you don't accidentally start a stream a s a viewer
        socket.on('start-broadcasting', function(typeOfStreams) {
            console.log('start-broadcasting', typeOfStreams);

            // host i.e. sender should always use this!
            connection.sdpConstraints.mandatory = {
                OfferToReceiveVideo: false,
                OfferToReceiveAudio: false
            };
            connection.session = typeOfStreams;

            // "open" method here will capture media-stream
            // we can skip this function always; it is totally optional here.
            // we can use "connection.getUserMediaHandler" instead
            connection.open(connection.userid);
        });
        */
    });

    window.onbeforeunload = function() {
        // Firefox is ugly.
        document.getElementById('open-or-join').disabled = false;
    };

    var videoPreview = document.getElementById('video-preview');

    connection.onstream = function(event) {
        if (connection.isInitiator && event.type !== 'local') {
            return;
        }

        connection.isUpperUserLeft = false;
        videoPreview.srcObject = event.stream;
        videoPreview.play();

        videoPreview.userid = event.userid;

        if (event.type === 'local') {
            videoPreview.muted = true;
        }

        if (connection.isInitiator == false && event.type === 'remote') {
            // he is merely relaying the media
            connection.dontCaptureUserMedia = true;
            connection.attachStreams = [event.stream];
            connection.sdpConstraints.mandatory = {
                OfferToReceiveAudio: false,
                OfferToReceiveVideo: false
            };

            connection.getSocket(function(socket) {
                socket.emit('can-relay-broadcast');

                if (connection.DetectRTC.browser.name === 'Chrome') {
                    connection.getAllParticipants().forEach(function(p) {
                        if (p + '' != event.userid + '') {
                            var peer = connection.peers[p].peer;
                            peer.getLocalStreams().forEach(function(localStream) {
                                peer.removeStream(localStream);
                            });
                            event.stream.getTracks().forEach(function(track) {
                                peer.addTrack(track, event.stream);
                            });
                            connection.dontAttachStream = true;
                            connection.renegotiate(p);
                            connection.dontAttachStream = false;
                        }
                    });
                }

                if (connection.DetectRTC.browser.name === 'Firefox') {
                    // Firefox is NOT supporting removeStream method
                    // that's why using alternative hack.
                    // NOTE: Firefox seems unable to replace-tracks of the remote-media-stream
                    // need to ask all deeper nodes to rejoin
                    connection.getAllParticipants().forEach(function(p) {
                        if (p + '' != event.userid + '') {
                            connection.replaceTrack(event.stream, p);
                        }
                    });
                }

                // Firefox seems UN_ABLE to record remote MediaStream
                // WebAudio solution merely records audio
                // so recording is skipped for Firefox.
                if (connection.DetectRTC.browser.name === 'Chrome') {
                    repeatedlyRecordStream(event.stream);
                }
            });
        }

        // to keep room-id in cache
        localStorage.setItem(connection.socketMessageEvent, connection.sessionid);
    };

    // ask node.js server to look for a broadcast
    // if broadcast is available, simply join it. i.e. "join-broadcaster" event should be emitted.
    // if broadcast is absent, simply create it. i.e. "start-broadcasting" event should be fired.
    /* This needs to be hooked up to fire using the buttons in the streamer list */
    document.getElementById('open-or-join').onclick = function() {
        var broadcastId = document.getElementById('broadcast-id').value;
        if (broadcastId.replace(/^\s+|\s+$/g, '').length <= 0) {
            alert('Please enter broadcast-id');
            document.getElementById('broadcast-id').focus();
            return;
        }

        document.getElementById('open-or-join').disabled = true;

        connection.extra.broadcastId = broadcastId;

        connection.session = {
            audio: true,
            video: true,
            oneway: true
        };

        connection.getSocket(function(socket) {
            socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                if (!isBroadcastExists) {
                    // the first person (i.e. real-broadcaster) MUST set his user-id
                    connection.userid = broadcastId;
                }

                console.log('check-broadcast-presence', broadcastId, isBroadcastExists);

                socket.emit('join-broadcast', {
                    broadcastId: broadcastId,
                    userid: connection.userid,
                    typeOfStreams: connection.session
                });
            });
        });
    };

    document.getElementById('join').onclick = function() {
        var broadcastId = document.getElementById('broadcast-id-slug').value;
        if (broadcastId.replace(/^\s+|\s+$/g, '').length <= 0) {
            alert('Please enter broadcast-id');
            document.getElementById('broadcast-id-slug').focus();
            return;
        }

        document.getElementById('join').disabled = true;

        connection.extra.broadcastId = broadcastId;

        connection.session = {
            audio: true,
            video: true,
            oneway: true
        };

        connection.getSocket(function(socket) {
            socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                if (!isBroadcastExists) {
                    // the first person (i.e. real-broadcaster) MUST set his user-id
                    //connection.userid = broadcastId;
                    console.log("Stream not live!");
                    alert("Stream not live :(");

                }else{

                    console.log('check-broadcast-presence', broadcastId, isBroadcastExists);

                    socket.emit('join-broadcast', {
                        broadcastId: broadcastId,
                        userid: connection.userid,
                        typeOfStreams: connection.session
                    });
                }
            });
        });
    };
    

    connection.onstreamended = function() {};

    connection.onleave = function(event) {
        if (event.userid !== videoPreview.userid) return;

        connection.getSocket(function(socket) {
            socket.emit('can-not-relay-broadcast');

            connection.isUpperUserLeft = true;

            if (allRecordedBlobs.length) {
                // playing lats recorded blob
                var lastBlob = allRecordedBlobs[allRecordedBlobs.length - 1];
                videoPreview.src = URL.createObjectURL(lastBlob);
                videoPreview.play();
                allRecordedBlobs = [];
            } else if (connection.currentRecorder) {
                var recorder = connection.currentRecorder;
                connection.currentRecorder = null;
                recorder.stopRecording(function() {
                    if (!connection.isUpperUserLeft) return;

                    videoPreview.src = URL.createObjectURL(recorder.getBlob());
                    videoPreview.play();
                });
            }

            if (connection.currentRecorder) {
                connection.currentRecorder.stopRecording();
                connection.currentRecorder = null;
            }
        });
    };

    var allRecordedBlobs = [];

    function repeatedlyRecordStream(stream) {
        if (!enableRecordings) {
            return;
        }

        connection.currentRecorder = RecordRTC(stream, {
            type: 'video'
        });

        connection.currentRecorder.startRecording();

        setTimeout(function() {
            if (connection.isUpperUserLeft || !connection.currentRecorder) {
                return;
            }

            connection.currentRecorder.stopRecording(function() {
                allRecordedBlobs.push(connection.currentRecorder.getBlob());

                if (connection.isUpperUserLeft) {
                    return;
                }

                connection.currentRecorder = null;
                repeatedlyRecordStream(stream);
            });
        }, 30 * 1000); // 30-seconds
    };

    function disableInputButtons() {
        document.getElementById('open-or-join').disabled = true;
        document.getElementById('broadcast-id').disabled = true;
    }

    // ......................................................
    // ......................Handling broadcast-id................
    // ......................................................

      /*var broadcastId = '';
    if (localStorage.getItem(connection.socketMessageEvent)) {
        broadcastId = localStorage.getItem(connection.socketMessageEvent);
    } else {
        broadcastId = connection.token();
    }
    var txtBroadcastId = document.getElementById('broadcast-id');
    txtBroadcastId.value = broadcastId;
    txtBroadcastId.addClass('hide');
    txtBroadcastId.onkeyup = txtBroadcastId.oninput = txtBroadcastId.onpaste = function() {
        localStorage.setItem(connection.socketMessageEvent, this.value);
    };*/

    // below section detects how many users are viewing your broadcast

    connection.onNumberOfBroadcastViewersUpdated = function(event) {
        if (!connection.isInitiator) return;

        document.getElementById('broadcast-viewers-counter').innerHTML = 'Number of broadcast viewers: <b>' + event.numberOfBroadcastViewers + '</b>';
    };

    // connect and get live stream list
    // livestreams needs to be cleared then have the list updated
    let socketlc = io.connect(window.location.origin, { transports: ['websocket'] });
    let usertoken = "";

    socketlc.on('connect', () => {
        load_chatToken();
        socketlc.emit('new user', {jwt:usertoken});

        socketlc.emit('getlivestreams');
        console.log("User connected!");
        
    });

    socketlc.on('livestreams', (data)=>{
        console.log("We should have a list stream list to update the UI:",data);
        updateStreamList(data.streams);
    });

    function doStreamConnect(streamid){
        /*var broadcastId = document.getElementById('broadcast-id').value;
        if (broadcastId.replace(/^\s+|\s+$/g, '').length <= 0) {
            alert('Please enter broadcast-id');
            document.getElementById('broadcast-id').focus();
            return;
        }*/

        connection.setHighBitrateModeAudio(false); // This should be used with a checkbox to configure if the stream should be high bitrate on the streamer side so it can be configured, automatically via config on the clients side
        disable_stream_connect = false;
        document.getElementById("livestreams").disabled = true;

        document.getElementById('open-or-join').disabled = true;
        let broadcastId = streamid;
        connection.extra.broadcastId = broadcastId;

        connection.session = {
            audio: true,
            video: true,
            oneway: true
        };

        connection.getSocket(function(socket) {
            socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                if (!isBroadcastExists) {
                    // the first person (i.e. real-broadcaster) MUST set his user-id
                    //connection.userid = broadcastId;
                }

                console.log('check-broadcast-presence', broadcastId, isBroadcastExists);
                if (isBroadcastExists) {
                    socket.emit('join-broadcast', {
                        broadcastId: broadcastId,
                        userid: connection.userid,
                        typeOfStreams: connection.session
                    });
                }else{
                    //alert("Stream is offline!");
                    console.log("Stream is now offline!");
                    disable_stream_connect = true;
                }
            });
        });
    }

    function updateStreamList(streams){
        // clear the streamer list
        $("#livestreams").empty();
        streams.forEach(stream => {
        let node = document.createElement("div"); 
            
            let textnodeAvatar = document.createElement("avatar");
                
                
                textnodeAvatar.classList.add("avatar");
            
                textnodeAvatar.innerHTML = "<img class=\"userav\" src=\"{{config.TROLLICON}}\" style=\"background: rgb(32, 99, 223);\">";
                if(stream.avatar){
                    textnodeAvatar.innerHTML = "<img class=\"userav\" src=\"" + stream.avatar + "\" style=\"background: rgb(32, 99, 223);\">";
                }
                
                textnodeAvatar.addEventListener('click', function(e){
                    // do something
                    /*let atmessage = $("textarea#message").val()
                        atmessage += "@" + user + " ";
                        $("textarea#message").val(atmessage)
                        $("textarea#message").focus();// send focus back to chat
                    }*/
                    console.log("Should attempt to connect to stream!",stream.user, stream.desc);
                    if(disable_stream_connect){
                        doStreamConnect(stream.user);
                    }
                });
                node.appendChild(textnodeAvatar); 

                let textnodeUserName = document.createElement("username"); // need to add a on click event for the attribute
                // need to add a onclick for username_click(el.username)
                textnodeUserName.addEventListener('click', function(e){
                    // do something
                    /*let atmessage = $("textarea#message").val()
                        atmessage = "!w " + user + " " + atmessage;
                        $("textarea#message").val(atmessage)
                        $("textarea#message").focus();// send focus back to chat
                    }*/
                    console.log("Should attempt to connect to stream!",stream.user, stream.desc);
                    if(disable_stream_connect){
                        doStreamConnect(stream.user);
                    }
                });
                
                textnodeUserName.innerHTML = '<span style=" color: white;">' + stream.user + "-" + stream.desc + ' Viewers: ' + stream.viewers + '</span>'; 
                
                
                
                node.appendChild(textnodeUserName);  
                
                //let textnode = document.createElement("message");
                //textnode.innerHTML = "<p>Ignore Toggle</p>"; 
                
                //node.appendChild(textnode); 

                document.getElementById("livestreams").appendChild(node);
                let nodebr = document.createElement("br"); 
                //document.getElementById("thewatchers").appendChild(nodebr);
                //document.getElementById("thewatchers").appendChild(nodebr);
                document.getElementById("livestreams").appendChild(nodebr);
        }); // end of for each stream/user
    }

    function parseToken (token) {
        try{
            var base64Url = token.split('.')[1];
            var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            var jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
        }catch(ex){
            console.log("failed to parse the token")
            return {user:{name:'failed'}}
        }
        return JSON.parse(jsonPayload);
    };

    function load_chatToken(){
        try {
            if(window.localStorage.chatToken){
                usertoken = window.localStorage.getItem('chatToken');
                //const temptoken = JSON.parse(usertoken);
                //console.log("My token loade:",temptoken);

                const usernametemp = parseToken(usertoken).sub.username;
                
                // this allows connections to be identified by their token name turned off to make it harder to ip scrape
                //document.getElementById('broadcast-id').value = usernametemp;
                //connection.userid = usernametemp;


                //const usernametemp = parseToken(usertoken).sub.username;
                //username_global = usernametemp;
                //$("#userid").val(usernametemp);
                return;
            }else{
                if(window.localStorage.trollToken){
                    load_trollToken();
                }else{
                    load_trollToken();
                }
            }

        }catch(ex){

        }
    }

    function load_trollToken(){
        try {
            if(window.localStorage.trollToken){
                usertoken = window.localStorage.getItem('trollToken');
                const usernametemp = parseToken(usertoken).sub.username;
                // disabled to be somewhat anon
                //document.getElementById('broadcast-id').value = usernametemp;
                //connection.userid = usernametemp;
                return;
            }else{
                mktroll();

                return;
            }

        }catch(ex){
            
        }
    }

    function mktroll(){
        const endpoint = '/mktroll';
                $.get( endpoint, function(data, status){
                    
                    if(status == "success"){
                        console.log("data:",data);
                        window.localStorage.setItem('trollToken'  , data  );
                        //load_chatToken();
                        load_trollToken();
                        //window.location.reload();
                    }
                });
    }

    // this should be hooked to a browser event every time the internet connection goes to online as well
    function getMyIp(){
        try{
            document.getElementById('ipinfo').innerText = "Error getting ip, check that popup blocker and ad blockers are disabled for this domain/page...";
      $.get('https://ipinfo.io', (response) => {
        console.log("ipinfo.io your public ip is:", response.ip);
        console.log("Full response:",response);
        vpn_info_org = response.org;
        vpn_info_ip = response.ip;
        //"org": "AS62240 Clouvider",
        // should be locked to the provider identified and warn if they do not match and show the new one
        document.getElementById('ipinfo').innerText = "Your public IP is: " + vpn_info_ip + " Your provider is detected as: " + vpn_info_org;

      },'json');
      }catch(error){
          console.log("Error checking ip info, check popup blocker extension on the site...");
            
            document.getElementById('ipinfo').innerText = "Error getting ip, check that popup blocker and ad blockers are disabled for this domain/page";
      }

       /*$.getJSON("http://jsonip.com/?callback=?", function (data) {
        console.log('jsonip.com your public ip is',data);
        //alert(data.ip);
        // https://cleantalk.org/blacklists/ip
        // https://ipinfo.io/AS212238/IP/subnetbits
        // curl -v https://ipinfo.io
        });*/
    }

    </script>
